{"version":3,"sources":["webpack:///./src/publish/share.vue?99dd","webpack:///./src/components/publish/album.vue?8af1","webpack:///./node_modules/luaparse/luaparse.js","webpack:///./src/components/publish/album.vue?2c17","webpack:///src/components/publish/album.vue","webpack:///./src/components/publish/album.vue?4803","webpack:///./src/components/publish/album.vue","webpack:///./node_modules/lua-json/index.js","webpack:///./src/publish/share.vue?cf96","webpack:///./src/service/share.js","webpack:///src/publish/share.vue","webpack:///./src/publish/share.vue?e894","webpack:///./src/publish/share.vue"],"names":["root","name","factory","objectTypes","freeExports","exports","nodeType","freeModule","module","freeGlobal","global","moduleExports","window","self","this","input","options","length","version","defaultOptions","wait","comments","scope","locations","ranges","onCreateNode","onCreateScope","onDestroyScope","EOF","StringLiteral","Keyword","Identifier","NumericLiteral","Punctuator","BooleanLiteral","NilLiteral","VarargLiteral","tokenTypes","errors","unexpected","expected","expectedToken","unfinishedString","malformedNumber","invalidVar","ast","labelStatement","label","type","breakStatement","gotoStatement","returnStatement","args","ifStatement","clauses","ifClause","condition","body","elseifClause","elseClause","whileStatement","doStatement","repeatStatement","localStatement","variables","init","assignmentStatement","callStatement","expression","functionStatement","identifier","parameters","isLocal","forNumericStatement","variable","start","end","step","forGenericStatement","iterators","chunk","literal","value","raw","tableKey","key","tableKeyString","tableValue","tableConstructorExpression","fields","binaryExpression","operator","left","right","unaryExpression","argument","memberExpression","base","indexer","indexExpression","index","callExpression","tableCallExpression","stringCallExpression","comment","finishNode","node","trackLocations","location","pop","complete","loc","range","token","previousToken","lookahead","tokenStart","line","lineStart","scopes","scopeDepth","globals","slice","Array","prototype","indexOf","Object","toString","array","element","i","indexOfObject","property","sprintf","format","call","arguments","replace","match","extend","src","prop","dest","hasOwnProperty","raise","error","col","message","apply","SyntaxError","column","raiseUnexpectedToken","found","near","lex","skipWhiteSpace","charCodeAt","scanComment","charCode","next","isIdentifierStart","scanIdentifierOrKeyword","scanStringLiteral","scanNumericLiteral","isDecDigit","scanVarargLiteral","scanPunctuator","scanLongStringLiteral","charAt","consumeEOL","peekCharCode","isLineTerminator","isWhiteSpace","isIdentifierPart","isKeyword","delimiter","stringStart","string","readEscapeSequence","String","fromCharCode","readLongString","character","readHexLiteral","readDecLiteral","digit","fractionStart","exponentStart","digitStart","fraction","binaryExponent","binarySign","isHexDigit","parseInt","Math","pow","parseFloat","sequenceStart","content","isLong","commentStart","lineStartComment","lineComment","push","level","terminator","consume","expect","id","isUnary","isCallExpression","isBlockFollow","createScope","destroyScope","scopeIdentifierName","scopeIdentifier","attachScope","scopeHasName","createLocationMarker","Marker","markLocation","pushLocation","marker","parseChunk","parseBlock","statement","block","parseStatement","parseLocalStatement","parseIfStatement","parseReturnStatement","parseFunctionName","parseFunctionDeclaration","parseWhileStatement","parseForStatement","parseRepeatStatement","parseBreakStatement","parseDoStatement","parseGotoStatement","parseLabelStatement","parseAssignmentOrCallStatement","parseIdentifier","parseExpectedExpression","expressions","parseExpression","l","validateVar","inParens","previous","parsePrefixExpression","exp","parameter","parsePrimaryExpression","parseTableConstructor","parseSubExpression","binaryPrecedence","minPrecedence","precedence","parseCallExpression","table","literals","parse","_input","_options","undefined","write","substr","Error","render","_vm","_h","$createElement","_c","_self","staticClass","ref","attrs","API","accept","fileList","change","handlePictureCardPreview","handleRemove","slot","dialogVisible","on","$event","dialogImageUrl","staticRenderFns","component","isNull","isBoolean","isNumber","isString","isArray","isObject","isEmpty","fromPairs","keys","map","repeat","parseLua","formatLuaString","singleQuote","formatLuaKey","eol","spaces","rec","spacesEnd","e","join","luaAstToJson","includes","__internal_table_key","object","field","values","post","meta","toPublish","toDraft","model","callback","$$v","$set","_v","_l","_s","post_meta","pics","updateAlbum","uploadData","selectData","directives","rawName","_e","formdata","vm","$_server"],"mappings":"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","file":"js/chunk-ace85d7c.08efc866.js","sourcesContent":["export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--10-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--10-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--10-oneOf-1-2!../../node_modules/less-loader/dist/cjs.js??ref--10-oneOf-1-3!../../node_modules/style-resources-loader/lib/index.js??ref--10-oneOf-1-4!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!../../node_modules/vue-svg-inline-loader/dist/index.min.js!./share.vue?vue&type=style&index=0&lang=less&\"","export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--10-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--10-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--10-oneOf-1-2!../../../node_modules/less-loader/dist/cjs.js??ref--10-oneOf-1-3!../../../node_modules/style-resources-loader/lib/index.js??ref--10-oneOf-1-4!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!../../../node_modules/vue-svg-inline-loader/dist/index.min.js!./album.vue?vue&type=style&index=0&lang=less&\"","/* global exports:true, module:true, require:true, define:true, global:true */\n\n(function (root, name, factory) {\n  /* jshint eqeqeq:false */\n  'use strict';\n\n  // Used to determine if values are of the language type `Object`\n  var objectTypes = {\n        'function': true\n      , 'object': true\n    }\n    // Detect free variable `exports`\n    , freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports\n    // Detect free variable `module`\n    , freeModule = objectTypes[typeof module] && module && !module.nodeType && module\n    // Detect free variable `global`, from Node.js or Browserified code, and\n    // use it as `window`\n    , freeGlobal = freeExports && freeModule && typeof global == 'object' && global\n    // Detect the popular CommonJS extension `module.exports`\n    , moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Some AMD build optimizers, like r.js, check for specific condition\n  // patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // defined as an anonymous module.\n    define(['exports'], factory);\n    // In case the source has been processed and wrapped in a define module use\n    // the supplied `exports` object.\n    if (freeExports && moduleExports) factory(freeModule.exports);\n  }\n  // check for `exports` after `define` in case a build optimizer adds an\n  // `exports` object\n  else if (freeExports && freeModule) {\n    // in Node.js or RingoJS v0.8.0+\n    if (moduleExports) factory(freeModule.exports);\n    // in Narwhal or RingoJS v0.7.0-\n    else factory(freeExports);\n  }\n  // in a browser or Rhino\n  else {\n    factory((root[name] = {}));\n  }\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = '0.2.1';\n\n  var input, options, length;\n\n  // Options can be set either globally on the parser object through\n  // defaultOptions, or during the parse call.\n  var defaultOptions = exports.defaultOptions = {\n    // Explicitly tell the parser when the input ends.\n      wait: false\n    // Store comments as an array in the chunk object.\n    , comments: true\n    // Track identifier scopes by adding an isLocal attribute to each\n    // identifier-node.\n    , scope: false\n    // Store location information on each syntax node as\n    // `loc: { start: { line, column }, end: { line, column } }`.\n    , locations: false\n    // Store the start and end character locations on each syntax node as\n    // `range: [start, end]`.\n    , ranges: false\n    // A callback which will be invoked when a syntax node has been completed.\n    // The node which has been created will be passed as the only parameter.\n    , onCreateNode: null\n    // A callback which will be invoked when a new scope is created.\n    , onCreateScope: null\n    // A callback which will be invoked when the current scope is destroyed.\n    , onDestroyScope: null\n  };\n\n  // The available tokens expressed as enum flags so they can be checked with\n  // bitwise operations.\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  // As this parser is a bit different from luas own, the error messages\n  // will be different in some situations.\n\n  var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n    , invalidVar: 'invalid left-hand side of assignment near \\'%1\\''\n  };\n\n  // ### Abstract Syntax Tree\n  //\n  // The default AST structure is inspired by the Mozilla Parser API but can\n  // easily be customized by overriding these functions.\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  // Wrap up the node object.\n\n  function finishNode(node) {\n    // Pop a `Marker` off the location-array and attach its location data.\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      if (options.locations) node.loc = location.loc;\n      if (options.ranges) node.range = location.range;\n    }\n    if (options.onCreateNode) options.onCreateNode(node);\n    return node;\n  }\n\n\n  // Helpers\n  // -------\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    , indexOf = function indexOf(array, element) {\n      for (var i = 0, length = array.length; i < length; i++) {\n        if (array[i] === element) return i;\n      }\n      return -1;\n    };\n\n  // Iterate through an array of objects and return the index of an object\n  // with a matching property.\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; i++) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  // A sprintf implementation using %index (beginning at 1) to input\n  // arguments in the format string.\n  //\n  // Example:\n  //\n  //     // Unexpected function in token\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || '';\n    });\n    return format;\n  }\n\n  // Returns a new object with the properties from all objectes passed as\n  // arguments. Last argument takes precedence.\n  //\n  // Example:\n  //\n  //     this.options = extend(options, { output: false });\n\n  function extend() {\n    var args = slice.call(arguments)\n      , dest = {}\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; i++) {\n      src = args[i];\n      for (prop in src) if (src.hasOwnProperty(prop)) {\n        dest[prop] = src[prop];\n      }\n    }\n    return dest;\n  }\n\n  // ### Error functions\n\n  // #### Raise an exception.\n  //\n  // Raise an exception by passing a token, a string format and its paramters.\n  //\n  // The passed tokens location will automatically be added to the error\n  // message if it exists, if not it will default to the lexers current\n  // position.\n  //\n  // Example:\n  //\n  //     // [1:0] expected [ near (\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if ('undefined' !== typeof token.line) {\n      col = token.range[0] - token.lineStart;\n      error = new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    } else {\n      col = index - lineStart + 1;\n      error = new SyntaxError(sprintf('[%1:%2] %3', line, col, message));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    }\n    throw error;\n  }\n\n  // #### Raise an unexpected token error.\n  //\n  // Example:\n  //\n  //     // expected <name> near '0'\n  //     raiseUnexpectedToken('<name>', token);\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, token.value);\n  }\n\n  // #### Raise a general unexpected error\n  //\n  // Usage should pass either a token object or a symbol string which was\n  // expected. We can also specify a nearby token such as <eof>, this will\n  // default to the currently active token.\n  //\n  // Example:\n  //\n  //     // Unexpected symbol 'end' near '<eof>'\n  //     unexpected(token);\n  //\n  // If there's no token in the buffer it means we have reached <eof>.\n\n  function unexpected(found, near) {\n    if ('undefined' === typeof near) near = lookahead.value;\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n      }\n      return raise(found, errors.unexpected, type, found.value, near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  // Lexer\n  // -----\n  //\n  // The lexer, or the tokenizer reads the input string character by character\n  // and derives a token left-right. To be as efficient as possible the lexer\n  // prioritizes the common cases such as identifiers. It also works with\n  // character codes instead of characters as string comparisons was the\n  // biggest bottleneck of the parser.\n  //\n  // If `options.comments` is enabled, all comments encountered will be stored\n  // in an array which later will be appended to the chunk object. If disabled,\n  // they will simply be disregarded.\n  //\n  // When the lexer has derived a valid token, it will be returned as an object\n  // containing its value and as well as its position in the input string (this\n  // is always enabled to provide proper debug messages).\n  //\n  // `lex()` starts lexing and returns the following token in the stream.\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n\n    // Skip comments beginning with --\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n\n    // Memorize the range index where the token begins.\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      // 0-9\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57:\n        return scanNumericLiteral();\n\n      case 46: // .\n        // If the dot is followed by a digit it's a float.\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (61 === next) return scanPunctuator('>=');\n        if (62 === next) return scanPunctuator('>>');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (60 === next) return scanPunctuator('<<');\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        return scanPunctuator('~');\n\n      case 58: // :\n        if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        // Check for a multiline string, they begin with [= or [[\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      case 47: // /\n        // Check for integer division op (//)\n        if (47 === next) return scanPunctuator('//');\n        return scanPunctuator('/');\n\n      // * ^ % , { } ] ( ) ; & # - + |\n      case 42: case 94: case 37: case 44: case 123: case 124: case 125:\n      case 93: case 40: case 41: case 59: case 38: case 35: case 45: case 43:\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\n  // tracking the encounted newlines. Any kind of eol sequence is counted as a\n  // single line.\n\n  function consumeEOL() {\n    var charCode = input.charCodeAt(index)\n      , peekCharCode = input.charCodeAt(index + 1);\n\n    if (isLineTerminator(charCode)) {\n      // Count \\n\\r and \\r\\n as one newline.\n      if (10 === charCode && 13 === peekCharCode) index++;\n      if (13 === charCode && 10 === peekCharCode) index++;\n      line++;\n      lineStart = ++index;\n\n      return true;\n    }\n    return false;\n  }\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        index++;\n      } else if (!consumeEOL()) {\n        break;\n      }\n    }\n  }\n\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\n  // simply go through them one by one and defaulting to an identifier if no\n  // previous case matched.\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n\n    // Slicing the input string is prefered before string concatenation in a\n    // loop for performance reasons.\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = input.slice(tokenStart, index);\n\n    // Decide on the token type and possibly cast the value.\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Once a punctuator reaches this function it should already have been\n  // validated so we simply return it as a token.\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // A vararg literal consists of three dots.\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Find the string literal by matching the delimiter marks used.\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , stringStart = index\n      , string = ''\n      , charCode;\n\n    while (index < length) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      if (92 === charCode) { // \\\n        string += input.slice(stringStart, index - 1) + readEscapeSequence();\n        stringStart = index;\n      }\n      // EOF or `\\n` terminates a string literal. If we haven't found the\n      // ending delimiter by now, raise an exception.\n      else if (index >= length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise({}, errors.unfinishedString, string + String.fromCharCode(charCode));\n      }\n    }\n    string += input.slice(stringStart, index - 1);\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Expect a multiline string literal and return it as a regular string\n  // literal, if it doesn't validate into a valid multiline string, throw an\n  // exception.\n\n  function scanLongStringLiteral() {\n    var string = readLongString();\n    // Fail if it's not a multiline literal.\n    if (false === string) raise(token, errors.expected, '[', token.value);\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Numeric literals will be returned as floating-point numbers instead of\n  // strings. The raw value should be retrieved from slicing the input string\n  // later on in the process.\n  //\n  // If a hexadecimal number is encountered, it will be converted.\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var value = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    return {\n        type: NumericLiteral\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Lua hexadecimals have an optional fraction part and an optional binary\n  // exoponent part. These are not included in JavaScript so we will compute\n  // all three parts separately and then sum them up at the end of the function\n  // with the following algorithm.\n  //\n  //     Digit := toDec(digit)\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\n  //     BinaryExp := 2 ^ binaryExp\n  //     Number := ( Digit + Fraction ) * BinaryExp\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n\n    // A minimum of one hex digit is required.\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) index++;\n    // Convert the hexadecimal digit to base 10.\n    digit = parseInt(input.slice(digitStart, index), 16);\n\n    // Fraction part i optional.\n    if ('.' === input.charAt(index)) {\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) index++;\n      fraction = input.slice(fractionStart, index);\n\n      // Empty fraction parts should default to 0, others should be converted\n      // 0.x form so we can use summation at the end.\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n\n    // Binary exponents are optional\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      index++;\n\n      // Sign part is optional and defaults to 1 (positive).\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n\n      // The binary exponent sign requires a decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) index++;\n      binaryExponent = input.slice(exponentStart, index);\n\n      // Calculate the binary exponent of the number.\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return (digit + fraction) * binaryExponent;\n  }\n\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\n  // this we check where the token ends and then parse it with native\n  // functions.\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) index++;\n    // Fraction part is optional\n    if ('.' === input.charAt(index)) {\n      index++;\n      // Fraction part defaults to 0\n      while (isDecDigit(input.charCodeAt(index))) index++;\n    }\n    // Exponent part is optional.\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      index++;\n      // Sign part is optional.\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) index++;\n      // An exponent is required to contain at least one decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) index++;\n    }\n\n    return parseFloat(input.slice(tokenStart, index));\n  }\n\n\n  // Translate escape sequences to the actual characters.\n\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      // Lua allow the following escape sequences.\n      // We don't escape the bell sequence.\n      case 'n': index++; return '\\n';\n      case 'r': index++; return '\\r';\n      case 't': index++; return '\\t';\n      case 'v': index++; return '\\x0B';\n      case 'b': index++; return '\\b';\n      case 'f': index++; return '\\f';\n      // Skips the following span of white-space.\n      case 'z': index++; skipWhiteSpace(); return '';\n      // Byte representation should for now be returned as is.\n      case 'x':\n        // \\xXX, where XX is a sequence of exactly two hexadecimal digits\n        if (isHexDigit(input.charCodeAt(index + 1)) &&\n            isHexDigit(input.charCodeAt(index + 2))) {\n          index += 3;\n          // Return it as is, without translating the byte.\n          return '\\\\' + input.slice(sequenceStart, index);\n        }\n        return '\\\\' + input.charAt(index++);\n      default:\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\n        if (isDecDigit(input.charCodeAt(index))) {\n          while (isDecDigit(input.charCodeAt(++index)));\n          return '\\\\' + input.slice(sequenceStart, index);\n        }\n        // Simply return the \\ as is, it's not escaping any sequence.\n        return input.charAt(index++);\n    }\n  }\n\n  // Comments begin with -- after which it will be decided if they are\n  // multiline comments or not.\n  //\n  // The multiline functionality works the exact same way as with string\n  // literals so we reuse the functionality.\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString();\n      // This wasn't a multiline comment after all.\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    // Scan until next line as long as it's not a multiline comment.\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        index++;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n\n      // `Marker`s depend on tokens available in the parser and as comments are\n      // intercepted in the lexer all location data is set manually.\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      comments.push(node);\n    }\n  }\n\n  // Read a multiline string by calculating the depth of `=` characters and\n  // then appending until an equal depth is found.\n\n  function readLongString() {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart;\n\n    index++; // [\n\n    // Calculate the depth of the comment.\n    while ('=' === input.charAt(index + level)) level++;\n    // Exit, this is not a long string afterall.\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n\n    // If the first character is a newline, ignore it and begin on next line.\n    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n    stringStart = index;\n    while (index < length) {\n      // To keep track of line numbers run the `consumeEOL()` which increments\n      // its counter.\n      if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n      character = input.charAt(index++);\n\n      // Once the delimiter is found, iterate through the depth count and see\n      // if it matches.\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; i++) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n\n      // We reached the end of the multiline string. Get out now.\n      if (terminator) break;\n    }\n    content += input.slice(stringStart, index - 1);\n    index += level + 1;\n\n    return content;\n  }\n\n  // ## Lex functions and helpers.\n\n  // Read the next token.\n  //\n  // This is actually done by setting the current token to the lookahead and\n  // reading in the new lookahead token.\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  // Consume a token if its value matches. Once consumed or not, return the\n  // success of the operation.\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  // Expect the next token value to match. If not, throw an exception.\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, token.value);\n  }\n\n  // ### Validation functions\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\n  // identifiers cannot use locale-dependet letters.\n\n  function isIdentifierStart(charCode) {\n    return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode;\n  }\n\n  function isIdentifierPart(charCode) {\n    return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57);\n  }\n\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\n  //\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        return 'else' === id || 'goto' === id || 'then' === id;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  // @TODO this needs to be rethought.\n  function isCallExpression(expression) {\n    switch (expression.type) {\n      case 'CallExpression':\n      case 'TableCallExpression':\n      case 'StringCallExpression':\n        return true;\n    }\n    return false;\n  }\n\n  // Check if the token syntactically closes a block.\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Scope\n  // -----\n\n  // Store each block scope as a an array of identifier names. Each scope is\n  // stored in an FILO-array.\n  var scopes\n    // The current scope index\n    , scopeDepth\n    // A list of all global identifier nodes.\n    , globals;\n\n  // Create a new scope inheriting all declarations from the previous scope.\n  function createScope() {\n    var scope = Array.apply(null, scopes[scopeDepth++]);\n    scopes.push(scope);\n    if (options.onCreateScope) options.onCreateScope();\n  }\n\n  // Exit and remove the current scope.\n  function destroyScope() {\n    var scope = scopes.pop();\n    scopeDepth--;\n    if (options.onDestroyScope) options.onDestroyScope();\n  }\n\n  // Add identifier name to the current scope if it doesnt already exist.\n  function scopeIdentifierName(name) {\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n\n  // Add identifier to the current scope\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n\n  // Attach scope information to node. If the node is global, store it in the\n  // globals array so we can return the information to the user.\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n\n  // Is the identifier name available in this scope.\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  // Location tracking\n  // -----------------\n  //\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\n  // location is added and the data is attached to a syntax node.\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n\n  // Complete the location data stored in the `Marker` by adding the location\n  // of the *previous token* as an end location.\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.line;\n      this.loc.end.column = previousToken.range[1] - previousToken.lineStart;\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  // Create a new `Marker` and add it to the FILO-array.\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n\n  // Push an arbitrary `Marker` object onto the FILO-array.\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  // Parse functions\n  // ---------------\n\n  // Chunk is the main program object. Syntactically it's the same as a block.\n  //\n  //     chunk ::= block\n\n  function parseChunk() {\n    next();\n    markLocation();\n    if (options.scope) createScope();\n    var body = parseBlock();\n    if (options.scope) destroyScope();\n    if (EOF !== token.type) unexpected(token);\n    // If the body is empty no previousToken exists when finishNode runs.\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  // A block contains a list of statements with an optional return statement\n  // as its last statement.\n  //\n  //     block ::= {stat} [retstat]\n\n  function parseBlock(terminator) {\n    var block = []\n      , statement;\n\n    while (!isBlockFollow(token)) {\n      // Return has to be the last statement in a block.\n      if ('return' === token.value) {\n        block.push(parseStatement());\n        break;\n      }\n      statement = parseStatement();\n      // Statements are only added if they are returned, this allows us to\n      // ignore some statements, such as EmptyStatement.\n      if (statement) block.push(statement);\n    }\n\n    // Doesn't really need an ast node\n    return block;\n  }\n\n  // There are two types of statements, simple and compound.\n  //\n  //     statement ::= break | goto | do | while | repeat | return\n  //          | if | for | function | local | label | assignment\n  //          | functioncall | ';'\n\n  function parseStatement() {\n    markLocation();\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement();\n        case 'if':       next(); return parseIfStatement();\n        case 'return':   next(); return parseReturnStatement();\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement();\n        case 'for':      next(); return parseForStatement();\n        case 'repeat':   next(); return parseRepeatStatement();\n        case 'break':    next(); return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement();\n        case 'goto':     next(); return parseGotoStatement();\n      }\n    }\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement();\n    }\n    // Assignments memorizes the location and pushes it manually for wrapper\n    // nodes. Additionally empty `;` statements should not mark a location.\n    if (trackLocations) locations.pop();\n\n    // When a `;` is encounted, simply eat it without storing it.\n    if (consume(';')) return;\n\n    return parseAssignmentOrCallStatement();\n  }\n\n  // ## Statements\n\n  //     label ::= '::' Name '::'\n\n  function parseLabelStatement() {\n    var name = token.value\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + name + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n    return finishNode(ast.labelStatement(label));\n  }\n\n  //     break ::= 'break'\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  //     goto ::= 'goto' Name\n\n  function parseGotoStatement() {\n    var name = token.value\n      , label = parseIdentifier();\n\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  //     do ::= 'do' block 'end'\n\n  function parseDoStatement() {\n    if (options.scope) createScope();\n    var body = parseBlock();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  //     while ::= 'while' exp 'do' block 'end'\n\n  function parseWhileStatement() {\n    var condition = parseExpectedExpression();\n    expect('do');\n    if (options.scope) createScope();\n    var body = parseBlock();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  //     repeat ::= 'repeat' block 'until' exp\n\n  function parseRepeatStatement() {\n    if (options.scope) createScope();\n    var body = parseBlock();\n    expect('until');\n    var condition = parseExpectedExpression();\n    if (options.scope) destroyScope();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  //     retstat ::= 'return' [exp {',' exp}] [';']\n\n  function parseReturnStatement() {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression();\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression();\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\n  //     elif ::= 'elseif' exp 'then' block\n\n  function parseIfStatement() {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n\n    // IfClauses begin at the same location as the parent IfStatement.\n    // It ends at the start of `end`, `else`, or `elseif`.\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression();\n    expect('then');\n    if (options.scope) createScope();\n    body = parseBlock();\n    if (options.scope) destroyScope();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression();\n      expect('then');\n      if (options.scope) createScope();\n      body = parseBlock();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      // Include the `else` in the location of ElseClause.\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      if (options.scope) createScope();\n      body = parseBlock();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  // There are two types of for statements, generic and numeric.\n  //\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\n  //     for ::= namelist 'in' explist 'do' block 'end'\n  //     namelist ::= Name {',' Name}\n  //     explist ::= exp {',' exp}\n\n  function parseForStatement() {\n    var variable = parseIdentifier()\n      , body;\n\n    // The start-identifier is local.\n\n    if (options.scope) {\n      createScope();\n      scopeIdentifier(variable);\n    }\n\n    // If the first expression is followed by a `=` punctuator, this is a\n    // Numeric For Statement.\n    if (consume('=')) {\n      // Start expression\n      var start = parseExpectedExpression();\n      expect(',');\n      // End expression\n      var end = parseExpectedExpression();\n      // Optional step expression\n      var step = consume(',') ? parseExpectedExpression() : null;\n\n      expect('do');\n      body = parseBlock();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    // If not, it's a Generic For Statement\n    else {\n      // The namelist can contain one or more identifiers.\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        // Each variable in the namelist is locally scoped.\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n\n      // One or more expressions in the explist.\n      do {\n        var expression = parseExpectedExpression();\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      body = parseBlock();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  // Local statements can either be variable assignments or function\n  // definitions. If a function definition is found, it will be delegated to\n  // `parseFunctionDeclaration()` with the isLocal flag.\n  //\n  // This AST structure might change into a local assignment with a function\n  // child.\n  //\n  //     local ::= 'local' 'function' Name funcdecl\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}]\n\n  function parseLocalStatement() {\n    var name;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression();\n          init.push(expression);\n        } while (consume(','));\n      }\n\n      // Declarations doesn't exist before the statement has been evaluated.\n      // Therefore assignments can't use their declarator. And the identifiers\n      // shouldn't be added to the scope until the statement is complete.\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; i++) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n\n      if (options.scope) {\n        scopeIdentifier(name);\n        createScope();\n      }\n\n      // MemberExpressions are not allowed in local function statements.\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  function validateVar(node) {\n    // @TODO we need something not dependent on the exact AST used. see also isCallExpression()\n    if (node.inParens || (['Identifier', 'MemberExpression', 'IndexExpression'].indexOf(node.type) === -1)) {\n      raise(token, errors.invalidVar, token.value);\n    }\n  }\n\n  //     assignment ::= varlist '=' explist\n  //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name\n  //     varlist ::= var {',' var}\n  //     explist ::= exp {',' exp}\n  //\n  //     call ::= callexp\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\n\n  function parseAssignmentOrCallStatement() {\n    // Keep a reference to the previous token for better error messages in case\n    // of invalid statement\n    var previous = token\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    expression = parsePrefixExpression();\n\n    if (null == expression) return unexpected(token);\n    if (',='.indexOf(token.value) >= 0) {\n      var variables = [expression]\n        , init = []\n        , exp;\n\n      validateVar(expression);\n      while (consume(',')) {\n        exp = parsePrefixExpression();\n        if (null == exp) raiseUnexpectedToken('<expression>', token);\n        validateVar(exp);\n        variables.push(exp);\n      }\n      expect('=');\n      do {\n        exp = parseExpectedExpression();\n        init.push(exp);\n      } while (consume(','));\n\n      pushLocation(marker);\n      return finishNode(ast.assignmentStatement(variables, init));\n    }\n    if (isCallExpression(expression)) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(expression));\n    }\n    // The prefix expression was neither part of an assignment or a\n    // callstatement, however as it was valid it's been consumed, so raise\n    // the exception on the previous token to provide a helpful message.\n    return unexpected(previous);\n  }\n\n\n\n  // ### Non-statements\n\n  //     Identifier ::= Name\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  // Parse the functions parameters and body block. The name should already\n  // have been parsed and passed to this declaration function. By separating\n  // this we allow for anonymous functions in expressions.\n  //\n  // For local functions there's a boolean parameter which needs to be set\n  // when parsing the declaration.\n  //\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var parameters = [];\n    expect('(');\n\n    // The declaration has arguments\n    if (!consume(')')) {\n      // Arguments are a comma separated list of identifiers, optionally ending\n      // with a vararg.\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          // Function parameters are local.\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n          else if (consume(')')) break;\n        }\n        // No arguments are allowed after a vararg.\n        else if (VarargLiteral === token.type) {\n          parameters.push(parsePrimaryExpression());\n          expect(')');\n          break;\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n      }\n    }\n\n    var body = parseBlock();\n    expect('end');\n    if (options.scope) destroyScope();\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  // Parse the function name as identifiers and member expressions.\n  //\n  //     Name {'.' Name} [':' Name]\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) {\n      attachScope(base, scopeHasName(base.name));\n      createScope();\n    }\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, ':', name));\n      if (options.scope) scopeIdentifierName('self');\n    }\n\n    return base;\n  }\n\n  //     tableconstructor ::= '{' [fieldlist] '}'\n  //     fieldlist ::= field {fieldsep field} fieldsep\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\n  //\n  //     fieldsep ::= ',' | ';'\n\n  function parseTableConstructor() {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression();\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression();\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        if ('=' === lookahead.value) {\n          key = parseIdentifier();\n          next();\n          value = parseExpectedExpression();\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          value = parseExpectedExpression();\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n      } else {\n        if (null == (value = parseExpression())) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  // Expression parser\n  // -----------------\n  //\n  // Expressions are evaluated and always return a value. If nothing is\n  // matched null will be returned.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n  //\n  //     primary ::= nil | false | true | Number | String | '...'\n  //          | functiondef | tableconstructor\n  //\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\n  //          | '.' Name | ':' Name args | args }\n  //\n\n  function parseExpression() {\n    var expression = parseSubExpression(0);\n    return expression;\n  }\n\n  // Parse an expression expecting it to be valid.\n\n  function parseExpectedExpression() {\n    var expression = parseExpression();\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n\n  // Return the precedence priority of the operator.\n  //\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\n  // isn't described in this table but in `parseSubExpression()` itself.\n  //\n  // As this function gets hit on every expression it's been optimized due to\n  // the expensive CompareICStub which took ~8% of the parse time.\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 12; // ^\n        case 42: case 47: case 37: return 10; // * / %\n        case 43: case 45: return 9; // + -\n        case 38: return 6; // &\n        case 126: return 5; // ~\n        case 124: return 4; // |\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 47: return 10; // //\n        case 46: return 8; // ..\n        case 60: case 62:\n            if('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3; // <= >=\n        case 61: case 126: return 3; // == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  // Implement an operator-precedence parser to handle binary operator\n  // precedence.\n  //\n  // We use this algorithm because it's compact, it's fast and Lua core uses\n  // the same so we can be sure our expressions are parsed in the same manner\n  // without excessive amounts of tests.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n\n  function parseSubExpression(minPrecedence) {\n    var operator = token.value\n    // The left-hand side in binary operations.\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // UnaryExpression\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(10);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      // PrimaryExpression\n      expression = parsePrimaryExpression();\n\n      // PrefixExpression\n      if (null == expression) {\n        expression = parsePrefixExpression();\n      }\n    }\n    // This is not a valid left hand expression.\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      // Right-hand precedence operators\n      if ('^' === operator || '..' === operator) precedence--;\n      next();\n      var right = parseSubExpression(precedence);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      // Push in the marker created before the loop to wrap its entirety.\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  //     prefixexp ::= prefix {suffix}\n  //     prefix ::= Name | '(' exp ')'\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\n  //\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parsePrefixExpression() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // The prefix\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      // Set the parent scope.\n      if (options.scope) attachScope(base, scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression();\n      expect(')');\n      base.inParens = true; // XXX: quick and dirty. needed for validateVar\n    } else {\n      return null;\n    }\n\n    // The suffix\n    var expression, identifier;\n    while (true) {\n      if (Punctuator === token.type) {\n        switch (token.value) {\n          case '[':\n            pushLocation(marker);\n            next();\n            expression = parseExpectedExpression();\n            base = finishNode(ast.indexExpression(base, expression));\n            expect(']');\n            break;\n          case '.':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            base = finishNode(ast.memberExpression(base, '.', identifier));\n            break;\n          case ':':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            base = finishNode(ast.memberExpression(base, ':', identifier));\n            // Once a : is found, this has to be a CallExpression, otherwise\n            // throw an error.\n            pushLocation(marker);\n            base = parseCallExpression(base);\n            break;\n          case '(': case '{': // args\n            pushLocation(marker);\n            base = parseCallExpression(base);\n            break;\n          default:\n            return base;\n        }\n      } else if (StringLiteral === token.type) {\n        pushLocation(marker);\n        base = parseCallExpression(base);\n      } else {\n        break;\n      }\n    }\n\n    return base;\n  }\n\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parseCallExpression(base) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          next();\n\n          // List of expressions\n          var expressions = [];\n          var expression = parseExpression();\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression();\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor();\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression()));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  //     primary ::= String | Numeric | nil | true | false\n  //          | functiondef | tableconstructor | '...'\n\n  function parsePrimaryExpression() {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      if (options.scope) createScope();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor();\n    }\n  }\n\n  // Parser\n  // ------\n\n  // Export the main parser.\n  //\n  //   - `wait` Hold parsing until end() is called. Defaults to false\n  //   - `comments` Store comments. Defaults to true.\n  //   - `scope` Track identifier scope. Defaults to false.\n  //   - `locations` Store location information. Defaults to false.\n  //   - `ranges` Store the start and end character locations. Defaults to\n  //     false.\n  //   - `onCreateNode` Callback which will be invoked when a syntax node is\n  //     created.\n  //   - `onCreateScope` Callback which will be invoked when a new scope is\n  //     created.\n  //   - `onDestroyScope` Callback which will be invoked when the current scope\n  //     is destroyed.\n  //\n  // Example:\n  //\n  //     var parser = require('luaparser');\n  //     parser.parse('i = 0');\n\n  exports.parse = parse;\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = extend(defaultOptions, _options);\n\n    // Rewind the lexer\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    // When tracking identifier scope, initialize with an empty scope.\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n\n  // Write to the source code buffer without beginning the parse.\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n\n  // Send an EOF and begin parsing.\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n\n    // Ignore shebangs.\n    if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n      return line.replace(/./g, ' ');\n    });\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    // Initialize with a lookahead token.\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n/* vim: set sw=2 ts=2 et tw=79 : */\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"c-album\"},[_c('el-upload',{ref:\"uploadbox\",attrs:{\"action\":_vm.API,\"with-credentials\":\"\",\"list-type\":\"picture-card\",\"auto-upload\":false,\"accept\":_vm.accept,\"limit\":10,\"multiple\":\"\",\"file-list\":_vm.fileList,\"on-change\":_vm.change,\"on-preview\":_vm.handlePictureCardPreview,\"on-remove\":_vm.handleRemove}},[_c('i',{staticClass:\"el-icon-plus\",attrs:{\"slot\":\"default\"},slot:\"default\"})]),_c('el-dialog',{attrs:{\"visible\":_vm.dialogVisible},on:{\"update:visible\":function($event){_vm.dialogVisible=$event}}},[_c('img',{attrs:{\"width\":\"100%\",\"src\":_vm.dialogImageUrl,\"alt\":\"\"}})])],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n    <div class=\"c-album\">\n        <el-upload\n            :action=\"API\"\n            with-credentials\n            list-type=\"picture-card\"\n            :auto-upload=\"false\"\n            :accept=\"accept\"\n            :limit=\"10\"\n            multiple\n            :file-list=\"fileList\"\n            :on-change=\"change\"\n            :on-preview=\"handlePictureCardPreview\"\n            :on-remove=\"handleRemove\"\n            ref=\"uploadbox\"\n        >\n            <i slot=\"default\" class=\"el-icon-plus\"></i>\n        </el-upload>\n        <el-dialog :visible.sync=\"dialogVisible\">\n            <img width=\"100%\" :src=\"dialogImageUrl\" alt=\"\" />\n        </el-dialog>\n    </div>\n</template>\n\n<script>\nimport allow_types from \"@jx3box/jx3box-common/data/conf\";\nimport { __server } from \"@jx3box/jx3box-common/data/jx3box.json\";\nimport {axios} from \"@/service/axios\";\n// import draggable from 'vuedraggable'\nconst imgtypes = [\"jpg\", \"png\", \"gif\", \"bmp\"];\nconst API = __server + \"upload\";\nexport default {\n    name: \"album\",\n    props: [\"imgList\"],\n    data: function() {\n        return {\n            API,\n            fileList: this.imgList || [],\n            accept: allow_types.accept,\n            sizeLimit: allow_types.sizeLimit,\n            dialogImageUrl: \"\",\n            dialogVisible: false,\n        };\n    },\n    computed: {},\n    methods: {\n        change: function(file, fileList) {\n            if (file.status != \"success\") {\n                // \n                if (file.size > this.sizeLimit) {\n                    this.$message.error(\"\");\n                    this.removeFile(fileList, file.uid);\n                    return;\n                }\n\n                // \n                let fdata = new FormData();\n                fdata.append(\"file\", file.raw);\n\n                // \n                axios\n                    .post(API, fdata, {\n                        headers: { \"Content-Type\": \"multipart/form-data\" },\n                        withCredentials: true,\n                    })\n                    .then((res) => {\n                        // \n                        this.$message({\n                            message: \"\",\n                            type: \"success\",\n                        });\n\n                        // path\n                        file.url = res.data.data.list[0];\n\n                        // // \n                        // let ext = file.name.split(\".\").pop();\n                        // let is_img = imgtypes.includes(ext);\n\n                        // // \n                        // file.is_img = is_img;\n                        // file.selected = false;\n\n                        // \n                        file.status = \"success\";\n                        this.fileList.push(file);\n                        this.$emit(\"albumChange\", this.fileList);\n                    })\n            }\n        },\n        handleRemove(file, fileList) {\n            this.fileList = fileList;\n            this.$emit(\"albumChange\", this.fileList);\n        },\n        handlePictureCardPreview(file) {\n            this.dialogImageUrl = file.url;\n            this.dialogVisible = true;\n        },\n        removeFile: function(fileList, uid) {\n            fileList.forEach((file, i) => {\n                if (file.uid == uid) {\n                    fileList.splice(i, 1);\n                }\n            });\n        },\n    },\n    mounted: function() {},\n    components: {\n        // draggable\n    },\n};\n</script>\n\n<style lang=\"less\">\n.c-album {\n    .el-dialog__body {\n        padding-top: 0;\n    }\n\n    .el-upload-list li {\n        outline: none;\n    }\n\n    .el-upload-list__item {\n        &:hover {\n            border: 1px solid #13ce66;\n        }\n    }\n\n    // \n    .u-file-wrapper {\n        .size(100%);\n        &.isSelected {\n        }\n        &.disabled {\n            cursor: default;\n            opacity: 0.38;\n            border-color: #eee;\n            .u-fileplaceholder {\n                fill: #aaa;\n            }\n        }\n        .pointer;\n    }\n    .u-filebox {\n        .x;\n        padding: 37px;\n    }\n    .u-fileplaceholder {\n        width: 40px;\n        height: 40px;\n        fill: @primary;\n    }\n    .u-filename {\n        .db;\n        .nobreak;\n    }\n}\n</style>\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!../../../node_modules/vue-svg-inline-loader/dist/index.min.js!./album.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!../../../node_modules/vue-svg-inline-loader/dist/index.min.js!./album.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./album.vue?vue&type=template&id=89c3dd6c&\"\nimport script from \"./album.vue?vue&type=script&lang=js&\"\nexport * from \"./album.vue?vue&type=script&lang=js&\"\nimport style0 from \"./album.vue?vue&type=style&index=0&lang=less&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","const { isNull, isBoolean, isNumber, isString, isArray, isObject, isEmpty, fromPairs, keys, map, repeat } = require('lodash')\nconst { parse: parseLua } = require('luaparse')\n\nconst formatLuaString = (string, singleQuote) => (singleQuote ? `'${string.replace(/'/g, \"\\\\'\")}'` : `\"${string.replace(/\"/g, '\\\\\"')}\"`)\n\nconst formatLuaKey = (string, singleQuote) => (string.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? string : `[${formatLuaString(string, singleQuote)}]`)\n\nconst format = (value, options = { eol: '\\n', singleQuote: true, spaces: 2 }) => {\n  options = options || {}\n  const eol = (options.eol = isString(options.eol) ? options.eol : '\\n')\n  options.singleQuote = isBoolean(options.singleQuote) ? options.singleQuote : true\n  options.spaces = isNull(options.spaces) || isNumber(options.spaces) || isString(options.spaces) ? options.spaces : 2\n\n  const rec = (value, i = 0) => {\n    if (isNull(value)) {\n      return 'nil'\n    }\n    if (isBoolean(value) || isNumber(value)) {\n      return value.toString()\n    }\n    if (isString(value)) {\n      return formatLuaString(value, options.singleQuote)\n    }\n    if (isArray(value)) {\n      if (isEmpty(value)) {\n        return '{}'\n      }\n      if (options.spaces) {\n        const spaces = isNumber(options.spaces) ? repeat(' ', options.spaces * (i + 1)) : repeat(options.spaces, i + 1)\n        const spacesEnd = isNumber(options.spaces) ? repeat(' ', options.spaces * i) : repeat(options.spaces, i)\n        return `{${eol}${value.map(e => `${spaces}${rec(e, i + 1)},`).join(eol)}${eol}${spacesEnd}}`\n      }\n      return `{${value.map(e => `${rec(e, i + 1)},`).join('')}}`\n    }\n    if (isObject(value)) {\n      if (isEmpty(value)) {\n        return '{}'\n      }\n      if (options.spaces) {\n        const spaces = isNumber(options.spaces) ? repeat(' ', options.spaces * (i + 1)) : repeat(options.spaces, i + 1)\n        const spacesEnd = isNumber(options.spaces) ? repeat(' ', options.spaces * i) : repeat(options.spaces, i)\n        return `{${eol}${keys(value)\n          .map(key => `${spaces}${formatLuaKey(key, options.singleQuote)} = ${rec(value[key], i + 1)},`)\n          .join(eol)}${eol}${spacesEnd}}`\n      }\n      return `{${keys(value)\n        .map(key => `${formatLuaKey(key, options.singleQuote)}=${rec(value[key], i + 1)},`)\n        .join('')}}`\n    }\n    throw new Error(`can't format ${typeof value}`)\n  }\n\n  return `return${options.spaces ? ' ' : ''}${rec(value)}`\n}\n\nconst luaAstToJson = ast => {\n  // literals\n  if (['NilLiteral', 'BooleanLiteral', 'NumericLiteral', 'StringLiteral'].includes(ast.type)) {\n    return ast.value\n  }\n  // basic expressions\n  if (ast.type === 'UnaryExpression' && ast.operator === '-') {\n    return -luaAstToJson(ast.argument)\n  }\n  if (ast.type === 'Identifier') {\n    return ast.name\n  }\n  // tables\n  if (['TableKey', 'TableKeyString'].includes(ast.type)) {\n    return { __internal_table_key: true, key: luaAstToJson(ast.key), value: luaAstToJson(ast.value) }\n  }\n  if (ast.type === 'TableValue') {\n    return luaAstToJson(ast.value)\n  }\n  if (ast.type === 'TableConstructorExpression') {\n    if (ast.fields[0] && ast.fields[0].key) {\n      const object = fromPairs(\n        map(ast.fields, field => {\n          const { key, value } = luaAstToJson(field)\n          return [key, value]\n        }),\n      )\n      return isEmpty(object) ? [] : object\n    }\n    return map(ast.fields, field => {\n      const value = luaAstToJson(field)\n      return value.__internal_table_key ? [value.key, value.value] : value\n    })\n  }\n  // top-level statements, only looking at the first statement, either return or local\n  // todo: filter until return or local?\n  if (ast.type === 'LocalStatement') {\n    const values = ast.init.map(luaAstToJson)\n    return values.length === 1 ? values[0] : values\n  }\n  if (ast.type === 'ReturnStatement') {\n    const values = ast.arguments.map(luaAstToJson)\n    return values.length === 1 ? values[0] : values\n  }\n  if (ast.type === 'Chunk') {\n    return luaAstToJson(ast.body[0])\n  }\n  throw new Error(`can't parse ${ast.type}`)\n}\n\nconst parse = value => luaAstToJson(parseLua(value, { comments: false }))\n\nmodule.exports = {\n  format,\n  parse,\n}\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"m-dashboard-publish-share\"},[(_vm.loaded)?_c('boilerplate',{attrs:{\"name\":_vm.name,\"type\":_vm.type,\"post\":_vm.post,\"meta\":_vm.meta,\"extend\":_vm.extend,\"infoEnable\":true,\"contentEnable\":false,\"markdownEnable\":false,\"excerptEnable\":true,\"tagEnable\":false,\"notifyEnable\":false,\"bannerEnable\":false},on:{\"publish\":_vm.toPublish,\"draft\":_vm.toDraft}},[[_c('el-form-item',{attrs:{\"label\":\"\"}},[_c('el-switch',{attrs:{\"active-color\":\"#13ce66\"},model:{value:(_vm.post.original),callback:function ($$v) {_vm.$set(_vm.post, \"original\", $$v)},expression:\"post.original\"}})],1),_c('el-form-item',{attrs:{\"label\":\"\"}},[_c('el-radio-group',{model:{value:(_vm.post.client),callback:function ($$v) {_vm.$set(_vm.post, \"client\", $$v)},expression:\"post.client\"}},[_c('el-radio',{attrs:{\"label\":\"std\"}},[_vm._v(\"\")]),_c('el-radio',{attrs:{\"label\":\"origin\"}},[_vm._v(\"\")]),_c('el-radio',{attrs:{\"label\":\"all\"}},[_vm._v(\"\")])],1)],1),_c('el-form-item',{attrs:{\"label\":\"\"}},[_c('el-radio-group',{model:{value:(_vm.post.post_subtype),callback:function ($$v) {_vm.$set(_vm.post, \"post_subtype\", $$v)},expression:\"post.post_subtype\"}},_vm._l((_vm.options.types),function(type,i){return _c('el-radio',{key:i,attrs:{\"border\":\"\",\"label\":type}},[_vm._v(_vm._s(type))])}),1)],1),_c('el-form-item',{attrs:{\"label\":\"\"}},[_c('el-input',{attrs:{\"placeholder\":\"\"},model:{value:(_vm.post.post_meta.author),callback:function ($$v) {_vm.$set(_vm.post.post_meta, \"author\", $$v)},expression:\"post.post_meta.author\"}})],1),_c('el-form-item',{attrs:{\"label\":\"\"}},[_c('album',{attrs:{\"imgList\":_vm.post.post_meta.pics},on:{\"albumChange\":_vm.updateAlbum}})],1),_c('el-form-item',{attrs:{\"label\":\"\"}},[_c('input',{staticClass:\"u-data-input\",attrs:{\"type\":\"file\",\"id\":\"face_file\"},on:{\"change\":_vm.uploadData}}),_c('el-button',{attrs:{\"type\":\"primary\",\"icon\":\"el-icon-upload2\"},on:{\"click\":_vm.selectData}},[_vm._v(\"\")]),_c('span',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.post.post_meta.file),expression:\"post.post_meta.file\"}],staticClass:\"u-data-ready\"},[_c('i',{staticClass:\"el-icon-success\"}),_vm._v(\"  \")])],1),_c('el-form-item',{attrs:{\"label\":\"\"}},[_c('el-input',{attrs:{\"type\":\"textarea\",\"rows\":6},model:{value:(_vm.post.post_meta.data),callback:function ($$v) {_vm.$set(_vm.post.post_meta, \"data\", $$v)},expression:\"post.post_meta.data\"}})],1)]],2):_vm._e()],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import { $_server } from \"./axios\";\n\nfunction uploadData(formdata, vm) {\n    return $_server.post(\"/upload/data\", formdata);\n}\n\n\nexport { uploadData };\n","<template>\n    <div class=\"m-dashboard-publish-share\">\n        <!--   -->\n        <!-- \n            localDraft : \n            infoEnable : \n            markdownEnable : markdown\n            excerptEnable : \n            tagEnable : \n            notifyEnable : \n            bannerEnable : ,\n         -->\n        <boilerplate\n            v-if=\"loaded\"\n            :name=\"name\"\n            :type=\"type\"\n            :post=\"post\"\n            :meta=\"meta\"\n            :extend=\"extend\"\n            :infoEnable=\"true\"\n            :contentEnable=\"false\"\n            :markdownEnable=\"false\"\n            :excerptEnable=\"true\"\n            :tagEnable=\"false\"\n            :notifyEnable=\"false\"\n            :bannerEnable=\"false\"\n            @publish=\"toPublish\"\n            @draft=\"toDraft\"\n        >\n            <template>\n                <el-form-item label=\"\">\n                    <el-switch v-model=\"post.original\" active-color=\"#13ce66\">\n                    </el-switch>\n                </el-form-item>\n\n                <el-form-item label=\"\">\n                    <el-radio-group v-model=\"post.client\">\n                        <el-radio label=\"std\"></el-radio>\n                        <el-radio label=\"origin\"></el-radio>\n                        <el-radio label=\"all\"></el-radio>\n                    </el-radio-group>\n                </el-form-item>\n\n                <el-form-item label=\"\">\n                    <el-radio-group v-model=\"post.post_subtype\">\n                        <el-radio\n                            border\n                            v-for=\"(type, i) in options.types\"\n                            :label=\"type\"\n                            :key=\"i\"\n                            >{{ type }}</el-radio\n                        >\n                    </el-radio-group>\n                </el-form-item>\n\n                <el-form-item label=\"\">\n                    <el-input\n                        v-model=\"post.post_meta.author\"\n                        placeholder=\"\"\n                    ></el-input>\n                </el-form-item>\n\n                <el-form-item label=\"\">\n                    <album\n                        :imgList=\"post.post_meta.pics\"\n                        @albumChange=\"updateAlbum\"\n                    ></album>\n                </el-form-item>\n\n                <el-form-item label=\"\">\n                    <input\n                        class=\"u-data-input\"\n                        type=\"file\"\n                        id=\"face_file\"\n                        @change=\"uploadData\"\n                    />\n                    <el-button\n                        type=\"primary\"\n                        @click=\"selectData\"\n                        icon=\"el-icon-upload2\"\n                        ></el-button\n                    >\n                    <span class=\"u-data-ready\" v-show=\"post.post_meta.file\">\n                        <i class=\"el-icon-success\"></i>\n                        \n                    </span>\n                </el-form-item>\n\n                <el-form-item label=\"\">\n                    <el-input\n                        v-model=\"post.post_meta.data\"\n                        type=\"textarea\"\n                        :rows=\"6\"\n                    ></el-input>\n                </el-form-item>\n            </template>\n        </boilerplate>\n    </div>\n</template>\n\n<script>\nimport boilerplate from \"@/components/publish/boilerplate\";\nimport { __ossMirror } from \"@jx3box/jx3box-common/data/jx3box.json\";\nimport album from \"@/components/publish/album.vue\";\n// import lodash from \"lodash\";\nimport { uploadData, parseData } from \"../service/share.js\";\nconst types = [\"\", \"\", \"\", \"\"];\nconst { parse } = require(\"lua-json\");\n\nexport default {\n    name: \"share\",\n    props: [],\n    data: function() {\n        return {\n            // - \n            type: \"share\",\n            name: \"\",\n            loaded: false,\n\n            //\n            options: {\n                types: types,\n            },\n\n            //\n            meta: {},\n\n            // - \n            post: {\n                ID: \"\", //ID\n                // post_author               //,token\n                // post_type:\"\",             //(boilerplate)\n                post_subtype: \"\", //()\n                post_title: \"\", //\n                post_content: \"\", //,meta\n                post_meta: {\n                    author: \"\", //\n                    pics: [], //\n                    file: \"\", //\n                    data: \"\", //\n                },\n                post_excerpt: \"\", //\n                post_mode: \"tinymce\", //()\n                post_banner: \"\", //,\n                post_status: \"\", //\n                // post_tags: [],            //\n                original: 0, //\n                client: \"std\", //,origin\n            },\n\n            // - \n            extend: {\n                feedEnable: false, //\n                followEnable: false, //\n                tencentEnable: false, //\n                weiboEnable: false, //\n                tuilanEnable: false, //\n            },\n        };\n    },\n    computed: {},\n    methods: {\n        // \n        init: function() {\n            return this.doLoad(this).then((data) => {});\n        },\n        // \n        toPublish: function() {\n            // console.log(this.build());\n            this.doPublish(this.build(), this).then((res) => {});\n        },\n        // \n        toDraft: function() {\n            this.doDraft(this.build(), this).then((res) => {});\n        },\n        // meta\n        build: function() {\n            let data = this.$store.state;\n            data.post.meta_1 = data.post.post_meta.author; //\n            return data;\n        },\n\n        // \n        updateAlbum: function(filelist) {\n            let imglist = [];\n            filelist.forEach((img) => {\n                imglist.push({\n                    name: img.name,\n                    url: img.url,\n                });\n            });\n            this.post.post_meta.pics = imglist;\n        },\n        // \n        selectData: function(i) {\n            let fileInput = document.getElementById(\"face_file\");\n            fileInput.dispatchEvent(new MouseEvent(\"click\"));\n        },\n        uploadData: function(e) {\n            let formdata = new FormData();\n            let file = e.target.files[0];\n            formdata.append(\"file\", file);\n            uploadData(formdata, this).then((res) => {\n                this.post.post_meta.file = res.data.data.list[0];\n                this.$message({\n                    message: '',\n                    type: \"success\",\n                });\n            });\n            this.parseData(file);\n        },\n        // \n        parseData: function(facedata) {\n\n            const vm = this\n\n            // \n            if (!FileReader) return;\n\n            let fr = new FileReader();\n            fr.readAsText(facedata);\n            fr.onload = function(e) {\n                console.log(\"......\");\n\n                let data = e.target.result;\n                data = \"return\" + data.slice(data.indexOf(\"{\"));\n\n                try {\n                    vm.post.post_meta.data = JSON.stringify(parse(data));\n                    vm.$notify({\n                        title: \"\",\n                        message: \"\",\n                        type: \"success\",\n                    });\n                } catch (e) {\n                    vm.$notify.error({\n                        title: \"\",\n                        message: \"\",\n                    });\n                }\n            };\n            fr.onerror = function(e) {\n                vm.$notify.error({\n                    title: \"\",\n                    message: \"\",\n                });\n            };\n        },\n    },\n    filters: {},\n    mounted: function() {\n        // \n        this.init().then(() => {\n            console.log(\"Init Post:\", this.post);\n        });\n    },\n    components: {\n        boilerplate,\n        album,\n    },\n};\n</script>\n\n<style lang=\"less\">\n@import \"../assets/css/publish/share.less\";\n</style>\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!../../node_modules/vue-svg-inline-loader/dist/index.min.js!./share.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!../../node_modules/vue-svg-inline-loader/dist/index.min.js!./share.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./share.vue?vue&type=template&id=70b27706&\"\nimport script from \"./share.vue?vue&type=script&lang=js&\"\nexport * from \"./share.vue?vue&type=script&lang=js&\"\nimport style0 from \"./share.vue?vue&type=style&index=0&lang=less&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}